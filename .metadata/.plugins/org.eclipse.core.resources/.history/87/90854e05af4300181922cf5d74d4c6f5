package Preprocessing;
	/** ZivLempel.java
 *
 * Created by Gus Silva and Anil Jethani
 *
 * The code for the compress and decompress functions
 * was written entirely by Gus Silva and Anil Jethani.
 * The algorithm implemented by the code is from the
 * Wikipedia documentation on Ziv-Lempel.
 */
/////////////////////  To change from files to strings////////////////


import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class LempleZivCompressor {

    public static void main(String args[])
    {
        String inFile = "files/input3.txt";
    String compressedFile = "files/compressed3.txt";
    String decompressedFile = "files/decompressed3.txt";
    compress(inFile, compressedFile);
    decompress(compressedFile, decompressedFile);
}

/**
 * @param inFilePath String with the path of the
 *                   file to be compressed.
 * @param outFilePath String with the path of the
 *                    file to write the compressed
 *                    output to.
 * @return boolean - True if compression is successful,
 *                   false otherwise.
 */

public static boolean compress(String inFilePath, String outFilePath)
{
    BufferedReader reader;
    BufferedWriter writer;
    try {
        //Prepare Input File
        reader = new BufferedReader(new FileReader(inFilePath));
        //Prepare Output File
        writer = new BufferedWriter(new FileWriter(outFilePath, false));

        /**
         * Anil and I have chosen to initialize the dictionary with only letters A-Z
         * for simplicity. However, we acknowledge that industrial strength
         * code would initialize dictionary with entire ASCII table.
         * */
        ArrayList<String> dictionary = new ArrayList<>(255);
        for(int i = 0; i < 26; i++)
        {
            String temp = (char)(i+65)+"";
            dictionary.add(temp);
        }

        String X, Z, line;
        while((line = reader.readLine()) != null)
        {
            int inc = 0;
            while( inc < line.length())
            {
                X = line.charAt(inc) + "";          //X is current character
                Z = line.charAt(++inc) + "";        //Z is next character

                while(dictionary.contains(X+Z))     //Loop until the sequence of
                {                                   //characters is not in dictionary
                    X = X+Z;
                    inc++;
                    if(inc < line.length())
                        Z = line.charAt(inc) + "";
                    else                            //Reached the end of input
                        Z = null;
                }
                dictionary.add(X+Z);                //Add String to dictionary

                //Write index to output
                writer.write(dictionary.indexOf(X) + " ");
            }
                writer.write("\n");
        }

        System.out.println(dictionary.toString());  //Print Dictionary
        reader.close();
        writer.close();
        return true;
    }
    catch( FileNotFoundException e)
    {
        System.out.println("Input file not found. Exiting.");
        return false;
    }
    catch (IOException e)
    {
        System.out.println("Error creating output file. Exiting.");
        return false;
    }

}

/**
 * @param inFilePath String with the path of the file
 *                   generated by the compression function
 *                   to be decompressed.
 * @param outFilePath String with path of the file to write
 *                    the decompressed output to.
 * @return boolean - true if successful, false otherwise.
 */
public static boolean decompress(String inFilePath, String outFilePath)
{
    BufferedReader reader;
    BufferedWriter writer;
    Scanner in;
    try
    {
        //Prepare Input File
        reader = new BufferedReader(new FileReader(inFilePath));
        in = new Scanner(reader);

        //Prepare Output File
        writer = new BufferedWriter(new FileWriter(outFilePath, false));

        /**
         * Anil and I have chosen to initialize the dictionary with only letters A-Z
         * for simplicity. However, we acknowledge that industrial strength
         * code would initialize dictionary with entire ASCII table.
         * */
        ArrayList<String> dictionary = new ArrayList<>(255);
        for(int i = 0; i < 26; i++)
        {
            String temp = (char)(i+65)+"";
            dictionary.add(temp);
        }

        String curr, X, Z;
        String[] line;
        Integer[] ints;

        while(in.hasNextLine())
        {
            curr = in.nextLine();
            line = curr.split(" ");                 // Convert input into an array
            ints = new Integer[line.length];
            for (int i = 0; i < ints.length; i++)   // Parse Strings in array into Ints
                ints[i] = Integer.parseInt(line[i]);// and transfer to Integer array

            for (int i = 0; i < ints.length; i++) {
                X = dictionary.get(ints[i]);
                if ((i+1) < ints.length && ints[i + 1] < dictionary.size())
                {
                    Z = dictionary.get(ints[i + 1]);
                    Z = Z.charAt(0) + "";           //Add first letter of next String
                }
                else if((i+1) >= ints.length)       //Reached end of input
                    Z = null;
                else                                //Dictionary does not have next index
                    Z = X.charAt(0) + "";           //must be first letter of current String

                dictionary.add(X+Z);                //Add new sequence to dictionary
                writer.write(X);                    //Write to output
            }
            writer.write("\n");
        }
        System.out.println(dictionary.toString());  //Print dictionary
        in.close();
        reader.close();
        writer.close();
        return true;
    }
    catch( FileNotFoundException e)
    {
        System.out.println("Input file not found. Exiting.");
        return false;
    }
    catch (IOException e)
    {
        System.out.println("Error creating output file. Exiting.");
            return false;
        }
    }
}


